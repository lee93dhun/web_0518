
=========================== 오리엔테이션 =======================================

- 6달 커리큘럼 -
	1. java 기초문법 
	2. java 고급문법 + UI JAVAFX		[ 포트1 ]	
	3. 프론트엔드[ 디자인 ] : HTML , CSS , JS
	4. 백엔드 [java] JSP			[ 포트2 ]
	5. [java] Spring 			
	6. [java] Spring			[ 포트3 ]

- 수업시간 -
	[ 3시간 ]
	13:00 ~ 13:50
	14:00 ~ 14:50
	15:00 ~ 15:50

- 연락처 - 
	카카오 플러스친구 : 아이티단자 

- 자료 제공 - 
	자료 홈페이지 : 아이티단자

- java 설치 - 
	1. 설치 : 
		1. JDK : 자바 개발 키트 
			1. JDK8 다운로드 
			2. [ ]윈도우 환경에 사용할수 있도록 환경변수  
				1. JAVA_HOME 		C:\jdk1.8.0_281 [ JDK 설치 경로 ]
				2. CLASSPATH		%JAVA_HOME%\lib
				3. path 편집 =>		%JAVA_HOME%\bin
			3. 확인 : 시작 => 검색 => cmd => java -version
		2. 이클립스 : 자바 에디터 

- 이클립스 사용하기 - 
	1. 워크스페이스 [ 작업폴더 ]
		2. java 프로젝트 [ 기본 java 라이브러리 제공 ]
			3. 패키지 [ 프로젝트내 폴더 ]
				4. 클래스 .java


============================= java 이론 =================================

	1. 컴퓨터 언어 : java , python , c ,c# 등
		1. 컴퓨터 구조 책
		2. 알고리즘 책 [ 백준 ]

	2. JAVA 특징 : 객체지향 [ 생활 -----> 컴퓨터 ]
		1. 100% 객체지향 
		2. 유니코드 사용 [ 전세계 공용어 ]
	
		-산업화 되면서 => 자동화, 대량생산 등 중요성이 커짐
	
		-클래스 : 설계도 
		-객체 : 설계도 기반으로 만들어진 제품 
	
			1. 붕어빵 클래스 : 밀가루 , 내용물 등 
			2. 객체 : 서로다른 붕어빵 여러개 생산 
		
			1. 자동차 클래스 : 엔진 , 의자 , 핸들 등 
			2. 객체 : 기아차 , 현대차 , 밴츠 여러개 생산 
		
			1. 회원 클래스 : 아이디 , 비밀번호 , 이메일 등 
			2. 객체 : 여러명의 회원들 
		
	
	3. 컴퓨터 [ 0 , 1 ] 기계어 <------- 아스키코드[번역]-------- 미국어 
			10000001									a
			10000002									b
	
	4. 코드 입력시 규칙 
		1. 클래스 안에 코드 작성 
		2. main 메소드 안에 있는 코드만 실행 가능 
		3. { : 시작  } : 끝	
		4. 클래스 , 메소드 등 을 제외한 코드 끝에 ; [ 세미콜론 ] : 일처리 
		5. 클래스내 멤버에 접근할때 .
			// 클래스명.멤버이름
		6. 키워드[미리 만들어진 단어 ] 제외 하고는 모든 문자에는 " " 처리 
		7. 숫자는 " " 처리 X
		8. CTRL+스페이바 : 자동완성 
		9. run [ ctrl+f11 ] 
		
	5. 컴파일 
	
	
	6. 메모리 [ 저장 장치 ] : 데이터 저장하는 공간 
		1. 변수 -> 메모리 할당받아 저장하는 공간 
			1. 변수 <--> 상수 
			2. 자료형[클래스] 사용  => new 생략 
			
		2. 객체 -> 메모리 할당받아 저장하는 공간 
			1. 클래스 기반으로 만들어진 메모리 할당 => new
			
	7. 용량단위 : 
		0 , 1 : 1비트  => 8비트 => 1바이트 [ byte ]
					 	01010101
	
	
		
=================================================================================
	[ 클래스 정리 ]
	
	1. System 클래스  : 전반적인 시스템 클래스 제공 
		1. System.out : 출력 
			1. println( ) : 자동 줄바꿈
			2. print( ) : 자동 줄바꿈X
			3. prinf( "형식문자" , 데이터 ) : 형식[꾸미기]
		
		2. System.in : 입력장치 : 키보드 

	2. Scanner 클래스  : 입력 클래스 
		1. nextInt() : 입력객체로 부터 정수형 받아오기 
		2. next() :  입력객체로 부터 문자열 받아오기 
		
	3. String 클래스 : 문자열 클래스 
		1. new 생략 가능 
		2. .equals() 비교 메소드  
		3. .getBytes() : 문자열 바이트단위 변환 
		
	4. Random 클래스 : 난수 클래스 
		1. .nextInt( 수 ) :   0 ~ (수-1) 앞까지의 난수(정수) 발생 
		2. .nextInt( 수 ) +시작값 : 시작값 ~ 수 까지의 난수(정수) 발생 
		
	5.Arrays 클래스 : 배열 클래스 
		1. Arrays.sort(배열명) :  해당 배열이 오름차순으로 정렬 
		2. Arrays.sort( 배열명 , Collections.reverseOrder() ) : 내림차순 정렬 
	
	6.ArrayList 클래스 : 컬렉션 프레임워크 중 하나 => 여러개 변수/객체 관리
		// 0. Arraylist<리스트에 담을 클래스명> 리스트명 = new Arraylist<>();
		
		// 1. 배열과 동일하지만 더 다양한 메소드 제공 
			// 리스트명.add(객체명) : 객체를 리스트에 저장 
			// 리스트명.get(인덱스번호) : 해당 인덱스의 객체를 호출  [ 인덱스번호 0번시작 ] 
			// 리스트명.size() : 리스트내 총 객체 수 
			// 리스트명.remove(인덱스번호) : 해당 인덱스의 객체 삭제
				// 배열과 다르게 객체 삭제시 => 삭제된 객체 뒤로 한칸씩 당겨짐
	
	7. 파일 클래스 
		1. FileOutputStream : 파일 쓰기 클래스 
			// 파일출력클래스		객체명[임의] = new[메모리할당연산자]	생성자("경로명/파일명" ) : 새로쓰기
			// 파일출력클래스		객체명[임의] = new[메모리할당연산자]	생성자("경로명/파일명" , true ) : 이어쓰기
			.write( 바이트 )
				// outputStream.write( 내용.getBytes() );
		2. FileInputStream : 파일 읽기 클래스 
			.read( 바이트 )
				// byte[] 바이트배열 = new byte[1024]; // 1kb
				// fileInputStream.read(바이트배열);
		* 문자열.getBytes() : 문자열 => 바이트
		* new String( 바이트 ) : 바이트 => 문자열 
	
	8. java 메일 클래스 
	
	9. 컬렉션 프레임워크 
			// 컬렉션 프레임워크 : 메모리 관리 클래스 집합
			// 컬렉션 : 수집
			// 프레임워크 : 미리 만들어진 프로그램
		// 1. List 컬렉션 
			// 1. ArrayList , 2. Vector , 3.LinkedList
				// 1. 배열과 차이점 : 배열[고정메모리] / list[가변메모리]
					// 배열 : int[] 배열명 = new int[10] => 10개 int형 메모리 우선 할당 
				// 2. 인덱스 사용 : 저장되는 순서 [0:시작~~ ]
				// 3. 추가,삭제시 : 인덱스 자동 변경 
				// 4. 자주 사용되는 메소드 
					// 1. 리스트명.add("객체명")
					// 2. 리스트명.get(인덱스번호)
					// 3. 리스트명.remove(인덱스번호)
					// 4. 리스트명.size()
					// 5. 리스트명.clear() 
				// 5.  ArrayList vs Vector : 동기화x:단일스레드  /  동기화o:멀티스레드
				// 6.  ArrayList vs LinkedList : 검색용이 / 삽입,삭제 용이
		// 2. Set 컬렉션 : 순서가 없는 저장 // 중복허용 X
				// 1. HashSet 클래스 
					// Iterator 인터페이스 이용한 요소 접근 
		
		// 3. Map 컬렉션 : 키,값 => 한쌍
				// 1. HashMap : 동기화X // 단일 스레드
					// 1. map.put( 키 , 값 ) => 키 값 중복불가
					// 2. map.get( 키 ) => 키 대응하는 값 호출 
					// 3. map.keySet() => 모든 키 호출 
		
				// 2. Hashtable : 동기화O // 멀티 스레드 
				
		// **** 차이점 정리 
			// List : 순서[인덱스] 기준으로 저장 
				// 1. ArrayList : 동기화X
				// 2. Vector : 동기화O
				// 3. LinkedList
			// Set : 순서없는 저장 => iterator 인터페이스
				// 1. HashSet
			// Map : 키,값 => 한쌍 저장  [ JSON 유사 ]
				// 1. HashMap : 동기화X
				// 2. Hashtable : 동기화O
				
///////////////////////////////////////////////////////////////////
		[  java 문법 ]
	
	2. 형식 문자 
		1. %d : 정수 들어가는 자리 
		2. %s : 문자열 들어가는 자리 
		
	3. 제어 문자 
		1. \n : 줄바꿈
		2. \t : 들여쓰기 
		
	4. 변수의 자료형 : 미리 만들어진 상자 크키 ====> 메모리 효율적 => 용량 줄이기 => 속도 증가 
		1. boolean : 1비트  	논리형
		2. char : 2바이트 	문자형
			// * 문자열은 String 클래스 사용 
		3. byte : 1바이트 	정수형
		4. short : 2바이트 	정수형
		5. int : 4바이트 		정수형	[ java 기본 자료형 ]  
		6. long : 8바이트 	정수형 
			// * 데이터뒤에 L 넣어주기 
		7. float : 4바이트 	실수형 
			// * 데이터뒤에 f 넣어주기 	
		8. double : 8바이트 	실수형 	[ java 기본 자료형 ]  
	
	5. 형 변환 
		1. 작은 용량 -> 큰 용량 변환 가능 
		2. 큰 용량에서 작은 용량 변환 불가능 
		3. 강제 형변환 : 큰 용량 => 작은 용량 강제로 변환 
			//  변수명 앞에 ( 변경할 자료형/클래스명 )
				//  int 정수 = (int) long형변수 
				
				
	6. 연산자 : 연산시 사용되는 특수문자 [ 두개 이상 연산자 있을경우 우선순위 ]
		1. 산술연산자 => 결과 : 값
			+더하기 -빼기 *곱하기 /나누기 %나머지
			
		2. 대입연산자 
			= [ 대입 : 오른쪽값이 왼쪽에 대입 ]
			+= [ 오른쪽값을 왼쪽값에 더한후 왼쪽값에 대입 ]
				변수 += 1			///		변수 = 변수 + 1 
			*=	/=	%=	-=
			
		3. 비교연산자 => 결과 : T(1) / F(0)
			> 초과	>= 이상	== 같다 [ String 객체 사용 불가 ]
			< 미만	<= 이하	!= 같지않다 [ 아니다 ]
	
		4. 논리연산자 [ 2개 이상의 비교연산자 사용시 ]
			&& : and[ 이면서 면서 이고 그리고 모두 ]
				변수1 >= 10 && 변수2 >= 30		비교연산자가 모두 T => T
				
			|| : or[ 이거나 거나 하나라도 또는 ]
			 	변수1 >= 10 || 변수2 >= 30		비교연산자가 하나라도 T => T
			 	
			! : not [ T => F ]
				!변수1>=10	T=>F 
		
		5. 증감연산자 [ 순차적인 증가/감소 ]
			++변수	: 선위 1증가	[ 해당 코드줄에서 우선 처리 ]
			변수++	: 후위 1증가	[ 해당 코드줄에서 마지막에 처리 ]
			--변수	: 선위 1감소
			변수--	: 후위 1감소 
			
		
		
		6. 제어문 = 1.제어/판단 2.T/F => 원하는 값으로 출력  
			* 주의할점 : 변수는 괄호 안으로 들어가수 있음 => 괄호 밖으로 나올수 없음 
					1. 괄호{ } 안에서 선언된 변수는 선언된 { } 안에서만 사용 가능  
			* if( 논리 ) ; [ X ]
			* if( 논리 ) { 실행코드 } ; [ X ]
			
			// 1. if
				1. if( 논리 t/f ) T=>실행코드 
				2. if( 논리 t/f ) {
						실행코드1;
						실행코드2;
					}
				3. if( 논리 t/f ) {
						T => 실행코드 
					}
					else{
						F => 실행코드 
					}
				4. if( 논리 t/f ) {
						T => 실행코드 
					}
					else if( 논리2 t/f ) {
						T => 실행코드 
					}
					else if( 논리3 t/f ) {
						T => 실행코드 
					}
					else {
						F => 실행코드 
					}
				5. if( 논리1 t/f ) 
				   if( 논리2 t/f ) 
				   if( 논리3 t/f ) 
				   if( 논리4 t/f ) 
				   
			// 2. switch( key) {  // break 필수
						case 값: 
						case 값: 
						case 값:
						default :
					}
			
		
		7. 무한반복 
			while(true){
			
				실행코드 
				if( 조건 ) break; // 반복문탈출 => 무한반복 종료 
				
			}

		8. 반복문 
			 1. for 문 ( 조건 ) => 중첩 for , 리스트
				// for( int i = 0 ; i<10 ; i += 3 )
				// for( 시작값 ; 조건문 ; 증감식 )
		
			 2. while 문 ( 조건 ) => 무한루프 
		
				 int i = 0 ; 시작값 
				 while( i<10 ){ // 조건문
						i++; // 증감식 	
				  }
		
		
			3. do ~ while 문 : 1번 먼저 실행후 검사 
		
				 
				  do{
				  
				  }while(조건문)
				  
		9. 배열 : 하나의 자료형/클래스 의 여러개 변수/객체 를 관리 
			// [ ] : 인덱스기준으로 순서대로 저장 
			// 1. 1차원배열  : 자료형 [] 배열명 = new 자료형[길이]
			// 2. 2차원배열  : 자료형[][] 배열명 = new 자료형[행길이][열길이]
			
			
		10.클래스 : 
			// 1. 클래스 설계 [ 필드(변수) , 메소드(함수) , 생성자 ]
			// 2. 클래스기반으로 객체 생성
				// 클래스명 객체명 = new 클래스명();
				// 클래스명 객체명 = new 클래스명(인수1 , 인수2 , 인수3 ~~~);
			// 3. 내용 담기 [ 객체는 클래스에 접근 가능 [ 접근연산자 : . ]
				// 1. 객체명.필드명
				// 2. new 클래스명(  ) : 생성자로 내용 담기 
			// 4. 메소드 : 함수
				// 함수 : 함[상자] 수[숫자] : 상자 안에 들어있는 수 => 미리 넣어둔 수 
				// 메소드 : 미리 작성된 코드
					// 1. 한번 사용되는 코드는 => 메소드로 만들 필요 없음
					// 1. 재활성[ 반복되는 코드 ] => 메소드 만들 효율성 크다 
					// 2. 복잡한 코드 묶음
					// 3. 인수 와 반환값 존재 [ 메모리 효율성 ]
						// 1. 인수 : 들어가는 수(코드)
						// 2. 반환 : 돌려주는 수(코드)
					// 4. 메소드{ } 안에서 선언된 변수는 실행후 종료되면 초기화
						// 남길 데이터는 반환해서 꺼내오기 
						// return
		
		11. 
			// 상속 : 클래스가 다른클래스에게 메모리 주기
				// extend : 연장  [ 설계 이어하기 ] 
					// 여러클래스에 공통멤버를 슈퍼클래스에 미리 설계하면 빠른 설계 가능 
				// 1. 서브클래스 extend 슈퍼클래스
					// 1. 상속은 하나의 클래스로부터 받음
				// 2. 서브클래스는 슈퍼클래스 멤버(필드,메소드,생성자)의 메모리 할당 받음
					// 1. 서브클래스 -> 슈퍼클래스 멤버 사용 가능 
					// 2. 슈퍼클래스 -> 서브클래스 멤버 사용 가능 X
					
				// 3. super() : 슈퍼클래스의 생성자 
				// 4. @Override : 슈퍼클래스의 메소드를 재정의
			
		// 1. 상속 : extends
			// 1. 슈퍼 클래스의 멤버를 상속받아 그대로 사용가능 혹은 재정의 가능
			// 2. extends 뒤에는 하나의 클래스만 가능 !!!!! 
			// super.멤버 : 슈퍼클래스에 멤버 접근 
			// @Override : 슈퍼클래스 멤버 재정의
		
		// 2. 인터페이스 : implements 
			// 1. 동일한 목적하에 동일한 메소드[기능]을 처리 역할 
			// 2. implements 뒤에는 여러개의 인테페이스 가능 
			// 특징 : 추상메소드를 선언만 => 실제 정의는 연결된 클래스에서 정의
			// @Override : 슈퍼클래스 멤버 재정의	
			
		12. 접근 제한자 
			// ** 접근제한자  : 필드 , 생성자 , 메소드 가 외부로부터 호출 제한 
				// 1. 선언시 맨 앞에서 작성 
				// 2. 종류 
						// 가정 : 프로젝트 내 접근 
					// public : 모든 곳에서 접근 가능
					// protected : 동일한 패키지내에서 접근 가능 [ 상속받은 클래스는 다른 패키지 접근 가능 ]
					// default   : 동일한 패키지내에서 접근 가능 
					// private : 현재 클래스에서만 접근 가능 
		
		13. 
		// 예외처리 : 오류 발생시에 처리 코드 
			// 1. 일반적인 오류는 코드에서 처리 
			// 2. 예상치 못한 오류 발생시[프로그램종료] => 예외처리 => 오류발생시에도 프로그램 정상화
				// 1. 코드상 문제가 없는경우
			// 3. 형태 
				// try{  오류발생 예상 코드  }
				// catch( 예외클래스 객체명 ){  오류발생시 대체 코드  } 
				// finally{ 무조건 실행되는 코드 }
			// 4. 예외클래스 
				// 1. 예외 이유를 알고 있는경우 : 해당 예외클래스 사용 
					// NullPointerException
					// NumberFormatException
					// ArrayIndexOutOfBoundsException 
					// 등등 
				// 2. 예외 이유를 다양하거나 모르는경우 :  Exception 클래스 사용 
					// Exception : 모든 Exception 처리 할수 있음 [ 슈퍼클래스 ]
			// 5. 예외 던지기 [ 오류 떠넘기기 ]
				// 1. 오류를 이동하여 한곳에서 처리 
				// 2. 접근제한자 반환자료형 메소드명( 인수 ) throws Exception { 예외코드 }
			// 6. 예외 만들기 
				// throw new Exception("예외이름");
			
		14. 스트림 : 입출력 데이터 교환 [ 단위 : 바이트 ]
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
